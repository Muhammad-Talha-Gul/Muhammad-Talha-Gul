!function(e){var n={};function t(o){if(n[o])return n[o].exports;var i=n[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(o,i,function(n){return e[n]}.bind(null,i));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="/dist/",t(t.s=27)}({0:function(e,n){e.exports=function(e){function n(e){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",e)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(e):"undefined"!=typeof eval?eval.call(null,e):n("EvalError: No eval function available")}catch(e){n(e)}}},27:function(e,n,t){t(28),e.exports=t(30)},28:function(e,n,t){t(0)(t(29))},29:function(e,n){e.exports='function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/*! echo-js v1.7.3 | (c) 2016 @toddmotto | https://github.com/toddmotto/echo */\n!function (t, e) {\n  "function" == typeof define && define.amd ? define(function () {\n    return e(t);\n  }) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? module.exports = e : t.echo = e(t);\n}(this, function (t) {\n  "use strict";\n\n  var e,\n      n,\n      o,\n      r,\n      c,\n      a = {},\n      u = function u() {},\n      d = function d(t) {\n    return null === t.offsetParent;\n  },\n      l = function l(t, e) {\n    if (d(t)) return !1;\n    var n = t.getBoundingClientRect();\n    return n.right >= e.l && n.bottom >= e.t && n.left <= e.r && n.top <= e.b;\n  },\n      i = function i() {\n    (r || !n) && (clearTimeout(n), n = setTimeout(function () {\n      a.render(), n = null;\n    }, o));\n  };\n\n  return a.init = function (n) {\n    n = n || {};\n\n    var d = n.offset || 0,\n        l = n.offsetVertical || d,\n        f = n.offsetHorizontal || d,\n        s = function s(t, e) {\n      return parseInt(t || e, 10);\n    };\n\n    e = {\n      t: s(n.offsetTop, l),\n      b: s(n.offsetBottom, l),\n      l: s(n.offsetLeft, f),\n      r: s(n.offsetRight, f)\n    }, o = s(n.throttle, 250), r = n.debounce !== !1, c = !!n.unload, u = n.callback || u, a.render(), document.addEventListener ? (t.addEventListener("scroll", i, !1), t.addEventListener("load", i, !1)) : (t.attachEvent("onscroll", i), t.attachEvent("onload", i));\n  }, a.render = function (n) {\n    for (var o, r, d = (n || document).querySelectorAll("[data-echo], [data-echo-background]"), i = d.length, f = {\n      l: 0 - e.l,\n      t: 0 - e.t,\n      b: (t.innerHeight || document.documentElement.clientHeight) + e.b,\n      r: (t.innerWidth || document.documentElement.clientWidth) + e.r\n    }, s = 0; i > s; s++) {\n      r = d[s], l(r, f) ? (c && r.setAttribute("data-echo-placeholder", r.src), null !== r.getAttribute("data-echo-background") ? r.style.backgroundImage = "url(" + r.getAttribute("data-echo-background") + ")" : r.src !== (o = r.getAttribute("data-echo")) && (r.src = o), c || (r.removeAttribute("data-echo"), r.removeAttribute("data-echo-background")), u(r, "load")) : c && (o = r.getAttribute("data-echo-placeholder")) && (null !== r.getAttribute("data-echo-background") ? r.style.backgroundImage = "url(" + o + ")" : r.src = o, r.removeAttribute("data-echo-placeholder"), u(r, "unload"));\n    }\n\n    i || a.detach();\n  }, a.detach = function () {\n    document.removeEventListener ? t.removeEventListener("scroll", i) : t.detachEvent("onscroll", i), clearTimeout(n);\n  }, a;\n});'},30:function(e,n,t){t(0)(t(31))},31:function(e,n){e.exports="function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (cc) {\n  // stop from running again, if accidently included more than once.\n  if (cc.hasInitialised) return;\n  var util = {\n    // https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\n    escapeRegExp: function escapeRegExp(str) {\n      return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n    },\n    hasClass: function hasClass(element, selector) {\n      var s = ' ';\n      return element.nodeType === 1 && (s + element.className + s).replace(/[\\n\\t]/g, s).indexOf(s + selector + s) >= 0;\n    },\n    addClass: function addClass(element, className) {\n      element.className += ' ' + className;\n    },\n    removeClass: function removeClass(element, className) {\n      var regex = new RegExp('\\\\b' + this.escapeRegExp(className) + '\\\\b');\n      element.className = element.className.replace(regex, '');\n    },\n    interpolateString: function interpolateString(str, callback) {\n      var marker = /{{([a-z][a-z0-9\\-_]*)}}/gi;\n      return str.replace(marker, function (matches) {\n        return callback(arguments[1]) || '';\n      });\n    },\n    getCookie: function getCookie(name) {\n      var value = '; ' + document.cookie;\n      var parts = value.split('; ' + name + '=');\n      return parts.length < 2 ? undefined : parts.pop().split(';').shift();\n    },\n    setCookie: function setCookie(name, value, expiryDays, domain, path, secure) {\n      var exdate = new Date();\n      exdate.setDate(exdate.getDate() + (expiryDays || 365));\n      var cookie = [name + '=' + value, 'expires=' + exdate.toUTCString(), 'path=' + (path || '/')];\n\n      if (domain) {\n        cookie.push('domain=' + domain);\n      }\n\n      if (secure) {\n        cookie.push('secure');\n      }\n\n      document.cookie = cookie.join(';');\n    },\n    // only used for extending the initial options\n    deepExtend: function deepExtend(target, source) {\n      for (var prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          if (prop in target && this.isPlainObject(target[prop]) && this.isPlainObject(source[prop])) {\n            this.deepExtend(target[prop], source[prop]);\n          } else {\n            target[prop] = source[prop];\n          }\n        }\n      }\n\n      return target;\n    },\n    // only used for throttling the 'mousemove' event (used for animating the revoke button when `animateRevokable` is true)\n    throttle: function throttle(callback, limit) {\n      var wait = false;\n      return function () {\n        if (!wait) {\n          callback.apply(this, arguments);\n          wait = true;\n          setTimeout(function () {\n            wait = false;\n          }, limit);\n        }\n      };\n    },\n    // only used for hashing json objects (used for hash mapping palette objects, used when custom colours are passed through JavaScript)\n    hash: function hash(str) {\n      var hash = 0,\n          i,\n          chr,\n          len;\n      if (str.length === 0) return hash;\n\n      for (i = 0, len = str.length; i < len; ++i) {\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0;\n      }\n\n      return hash;\n    },\n    normaliseHex: function normaliseHex(hex) {\n      if (hex[0] == '#') {\n        hex = hex.substr(1);\n      }\n\n      if (hex.length == 3) {\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n      }\n\n      return hex;\n    },\n    // used to get text colors if not set\n    getContrast: function getContrast(hex) {\n      hex = this.normaliseHex(hex);\n      var r = parseInt(hex.substr(0, 2), 16);\n      var g = parseInt(hex.substr(2, 2), 16);\n      var b = parseInt(hex.substr(4, 2), 16);\n      var yiq = (r * 299 + g * 587 + b * 114) / 1000;\n      return yiq >= 128 ? '#000' : '#fff';\n    },\n    // used to change color on highlight\n    getLuminance: function getLuminance(hex) {\n      var num = parseInt(this.normaliseHex(hex), 16),\n          amt = 38,\n          R = (num >> 16) + amt,\n          B = (num >> 8 & 0x00ff) + amt,\n          G = (num & 0x0000ff) + amt;\n      var newColour = (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (B < 255 ? B < 1 ? 0 : B : 255) * 0x100 + (G < 255 ? G < 1 ? 0 : G : 255)).toString(16).slice(1);\n      return '#' + newColour;\n    },\n    isMobile: function isMobile() {\n      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    },\n    isPlainObject: function isPlainObject(obj) {\n      // The code \"typeof obj === 'object' && obj !== null\" allows Array objects\n      return _typeof(obj) === 'object' && obj !== null && obj.constructor == Object;\n    },\n    traverseDOMPath: function traverseDOMPath(elem, className) {\n      if (!elem || !elem.parentNode) return null;\n      if (util.hasClass(elem, className)) return elem;\n      return this.traverseDOMPath(elem.parentNode, className);\n    }\n  }; // valid cookie values\n\n  cc.status = {\n    deny: 'deny',\n    allow: 'allow',\n    dismiss: 'dismiss'\n  }; // detects the `transitionend` event name\n\n  cc.transitionEnd = function () {\n    var el = document.createElement('div');\n    var trans = {\n      t: 'transitionend',\n      OT: 'oTransitionEnd',\n      msT: 'MSTransitionEnd',\n      MozT: 'transitionend',\n      WebkitT: 'webkitTransitionEnd'\n    };\n\n    for (var prefix in trans) {\n      if (trans.hasOwnProperty(prefix) && typeof el.style[prefix + 'ransition'] != 'undefined') {\n        return trans[prefix];\n      }\n    }\n\n    return '';\n  }();\n\n  cc.hasTransition = !!cc.transitionEnd; // array of valid regexp escaped statuses\n\n  var __allowedStatuses = Object.keys(cc.status).map(util.escapeRegExp); // contains references to the custom <style> tags\n\n\n  cc.customStyles = {};\n\n  cc.Popup = function () {\n    var defaultOptions = {\n      // if false, this prevents the popup from showing (useful for giving to control to another piece of code)\n      enabled: true,\n      // optional (expecting a HTML element) if passed, the popup is appended to this element. default is `document.body`\n      container: null,\n      // defaults cookie options - it is RECOMMENDED to set these values to correspond with your server\n      cookie: {\n        // This is the name of this cookie - you can ignore this\n        name: 'cookieconsent_status',\n        // This is the url path that the cookie 'name' belongs to. The cookie can only be read at this location\n        path: '/',\n        // This is the domain that the cookie 'name' belongs to. The cookie can only be read on this domain.\n        //  - Guide to cookie domains - https://www.mxsasha.eu/blog/2014/03/04/definitive-guide-to-cookie-domains/\n        domain: '',\n        // The cookies expire date, specified in days (specify -1 for no expiry)\n        expiryDays: 365,\n        // If true the cookie will be created with the secure flag. Secure cookies will only be transmitted via HTTPS.\n        secure: false\n      },\n      // these callback hooks are called at certain points in the program execution\n      onPopupOpen: function onPopupOpen() {},\n      onPopupClose: function onPopupClose() {},\n      onInitialise: function onInitialise(status) {},\n      onStatusChange: function onStatusChange(status, chosenBefore) {},\n      onRevokeChoice: function onRevokeChoice() {},\n      onNoCookieLaw: function onNoCookieLaw(countryCode, country) {},\n      // each item defines the inner text for the element that it references\n      content: {\n        header: 'Cookies used on the website!',\n        message: 'This website uses cookies to ensure you get the best experience on our website.',\n        dismiss: 'Got it!',\n        allow: 'Allow cookies',\n        deny: 'Decline',\n        link: '',\n        href: '',\n        close: '&#x274c;',\n        target: '_blank',\n        policy: 'Cookie Policy',\n        policy_link: '',\n        privacy_link: '',\n        terms_link: ''\n      },\n      // This is the HTML for the elements above. The string {{header}} will be replaced with the equivalent text below.\n      // You can remove \"{{header}}\" and write the content directly inside the HTML if you want.\n      //\n      //  - ARIA rules suggest to ensure controls are tabbable (so the browser can find the first control),\n      //    and to set the focus to the first interactive control (https://w3c.github.io/using-aria/)\n      elements: {\n        header: '<span class=\"cc-header\">{{header}}</span>&nbsp;',\n        message: '<span id=\"cookieconsent:desc\" class=\"cc-message\">{{message}}</span>',\n        messagelink: '<span id=\"cookieconsent:desc\" class=\"cc-message\">{{message}} </span>',\n        dismiss: '<a aria-label=\"dismiss cookie message\" role=button tabindex=\"0\" class=\"cc-btn cc-dismiss\">{{dismiss}}</a>',\n        allow: '<a aria-label=\"allow cookies\" role=button tabindex=\"0\"  class=\"cc-btn cc-allow\">{{allow}}</a>',\n        deny: '<a aria-label=\"deny cookies\" role=button tabindex=\"0\" class=\"cc-btn cc-deny\">{{deny}}</a>',\n        link: '<a aria-label=\"learn more about cookies\" role=button tabindex=\"0\" class=\"cc-link\" href=\"{{href}}\" rel=\"noopener noreferrer nofollow\" target=\"{{target}}\">{{link}}</a>',\n        close: '<span aria-label=\"dismiss cookie message\" role=button tabindex=\"0\" class=\"cc-close\">{{close}}</span>' //compliance: compliance is also an element, but it is generated by the application, depending on `type` below\n\n      },\n      // The placeholders {{classes}} and {{children}} both get replaced during initialisation:\n      //  - {{classes}} is where additional classes get added\n      //  - {{children}} is where the HTML children are placed\n      window: '<div role=\"dialog\" aria-live=\"polite\" aria-label=\"cookieconsent\" aria-describedby=\"cookieconsent:desc\" class=\"cc-window {{classes}}\">\x3c!--googleoff: all--\x3e{{children}}\x3c!--googleon: all--\x3e</div>',\n      // This is the html for the revoke button. This only shows up after the user has selected their level of consent\n      // It can be enabled of disabled using the `revokable` option\n      revokeBtn: '<div class=\"cc-revoke {{classes}}\">{{policy}}</div>',\n      // define types of 'compliance' here. '{{value}}' strings in here are linked to `elements`\n      compliance: {\n        info: '<div class=\"cc-compliance\">{{dismiss}}</div>',\n        'opt-in': '<div class=\"cc-compliance cc-highlight\">{{deny}}{{allow}}</div>',\n        'opt-out': '<div class=\"cc-compliance cc-highlight\">{{deny}}{{allow}}</div>'\n      },\n      // select your type of popup here\n      type: 'info',\n      // refers to `compliance` (in other words, the buttons that are displayed)\n      // define layout layouts here\n      layouts: {\n        // the 'block' layout tend to be for square floating popups\n        basic: '{{messagelink}}{{compliance}}',\n        'basic-close': '{{messagelink}}{{compliance}}{{close}}',\n        'basic-header': '{{header}}{{message}}{{link}}{{compliance}}' // add a custom layout here, then add some new css with the class '.cc-layout-my-cool-layout'\n        //'my-cool-layout': '<div class=\"my-special-layout\">{{message}}{{compliance}}</div>{{close}}',\n\n      },\n      // default layout (see above)\n      layout: 'basic',\n      // this refers to the popup windows position. we currently support:\n      //  - banner positions: top, bottom\n      //  - floating positions: top-left, top-right, bottom-left, bottom-right\n      //\n      // adds a class `cc-floating` or `cc-banner` which helps when styling\n      position: 'bottom',\n      // default position is 'bottom'\n      // Available styles\n      //    -block (default, no extra classes)\n      //    -edgeless\n      //    -classic\n      // use your own style name and use `.cc-theme-STYLENAME` class in CSS to edit.\n      // Note: style \"wire\" is used for the configurator, but has no CSS styles of its own, only palette is used.\n      theme: 'block',\n      // The popup is `fixed` by default, but if you want it to be static (inline with the page content), set this to false\n      // Note: by default, we animate the height of the popup from 0 to full size\n      static: false,\n      // if you want custom colours, pass them in here. this object should look like this.\n      // ideally, any custom colours/themes should be created in a separate style sheet, as this is more efficient.\n      //   {\n      //     popup: {background: '#000000', text: '#fff', link: '#fff'},\n      //     button: {background: 'transparent', border: '#f8e71c', text: '#f8e71c'},\n      //     highlight: {background: '#f8e71c', border: '#f8e71c', text: '#000000'},\n      //   }\n      // `highlight` is optional and extends `button`. if it exists, it will apply to the first button\n      // only background needs to be defined for every element. if not set, other colors can be calculated from it\n      palette: null,\n      // Some countries REQUIRE that a user can change their mind. You can configure this yourself.\n      // Most of the time this should be false, but the `cookieconsent.law` can change this to `true` if it detects that it should\n      revokable: false,\n      // if true, the revokable button will tranlate in and out\n      animateRevokable: true,\n      // used to disable link on existing layouts\n      // replaces element messagelink with message and removes content of link\n      showLink: true,\n      // set value as scroll range to enable\n      dismissOnScroll: false,\n      // set value as time in milliseconds to autodismiss after set time\n      dismissOnTimeout: false,\n      // set value as click anything on the page, excluding the `ignoreClicksFrom` below (if we click on the revoke button etc)\n      dismissOnWindowClick: false,\n      // If `dismissOnWindowClick` is true, we can click on 'revoke' and we'll still dismiss the banner, so we need exceptions.\n      // should be an array of class names (not CSS selectors)\n      ignoreClicksFrom: ['cc-revoke', 'cc-btn'],\n      // already includes the revoke button and the banner itself\n      // The application automatically decide whether the popup should open.\n      // Set this to false to prevent this from happening and to allow you to control the behaviour yourself\n      autoOpen: true,\n      // By default the created HTML is automatically appended to the container (which defaults to <body>). You can prevent this behaviour\n      // by setting this to false, but if you do, you must attach the `element` yourself, which is a public property of the popup instance:\n      //\n      //     var instance = cookieconsent.factory(options);\n      //     document.body.appendChild(instance.element);\n      //\n      autoAttach: true,\n      // simple whitelist/blacklist for pages. specify page by:\n      //   - using a string : '/index.html'           (matches '/index.html' exactly) OR\n      //   - using RegExp   : /\\/page_[\\d]+\\.html/    (matched '/page_1.html' and '/page_2.html' etc)\n      whitelistPage: [],\n      blacklistPage: [],\n      // If this is defined, then it is used as the inner html instead of layout. This allows for ultimate customisation.\n      // Be sure to use the classes `cc-btn` and `cc-allow`, `cc-deny` or `cc-dismiss`. They enable the app to register click\n      // handlers. You can use other pre-existing classes too. See `src/styles` folder.\n      overrideHTML: null\n    };\n\n    function CookiePopup() {\n      this.initialise.apply(this, arguments);\n    }\n\n    CookiePopup.prototype.initialise = function (options) {\n      if (this.options) {\n        this.destroy(); // already rendered\n      } // set options back to default options\n\n\n      util.deepExtend(this.options = {}, defaultOptions); // merge in user options\n\n      if (util.isPlainObject(options)) {\n        util.deepExtend(this.options, options);\n      } // returns true if `onComplete` was called\n\n\n      if (checkCallbackHooks.call(this)) {\n        // user has already answered\n        this.options.enabled = false;\n      } // apply blacklist / whitelist\n\n\n      if (arrayContainsMatches(this.options.blacklistPage, location.pathname)) {\n        this.options.enabled = false;\n      }\n\n      if (arrayContainsMatches(this.options.whitelistPage, location.pathname)) {\n        this.options.enabled = true;\n      } // the full markup either contains the wrapper or it does not (for multiple instances)\n\n\n      var cookiePopup = this.options.window.replace('{{classes}}', getPopupClasses.call(this).join(' ')).replace('{{children}}', getPopupInnerMarkup.call(this)); // if user passes html, use it instead\n\n      var customHTML = this.options.overrideHTML;\n\n      if (typeof customHTML == 'string' && customHTML.length) {\n        cookiePopup = customHTML;\n      } // if static, we need to grow the element from 0 height so it doesn't jump the page\n      // content. we wrap an element around it which will mask the hidden content\n\n\n      if (this.options.static) {\n        // `grower` is a wrapper div with a hidden overflow whose height is animated\n        var wrapper = appendMarkup.call(this, '<div class=\"cc-grower\">' + cookiePopup + '</div>');\n        wrapper.style.display = ''; // set it to visible (because appendMarkup hides it)\n\n        this.element = wrapper.firstChild; // get the `element` reference from the wrapper\n\n        this.element.style.display = 'none';\n        util.addClass(this.element, 'cc-invisible');\n      } else {\n        this.element = appendMarkup.call(this, cookiePopup);\n      }\n\n      applyAutoDismiss.call(this);\n      applyRevokeButton.call(this);\n\n      if (this.options.autoOpen) {\n        this.autoOpen();\n      }\n    };\n\n    CookiePopup.prototype.destroy = function () {\n      if (this.onButtonClick && this.element) {\n        this.element.removeEventListener('click', this.onButtonClick);\n        this.onButtonClick = null;\n      }\n\n      if (this.dismissTimeout) {\n        clearTimeout(this.dismissTimeout);\n        this.dismissTimeout = null;\n      }\n\n      if (this.onWindowScroll) {\n        window.removeEventListener('scroll', this.onWindowScroll);\n        this.onWindowScroll = null;\n      }\n\n      if (this.onWindowClick) {\n        window.removeEventListener('click', this.onWindowClick);\n        this.onWindowClick = null;\n      }\n\n      if (this.onMouseMove) {\n        window.removeEventListener('mousemove', this.onMouseMove);\n        this.onMouseMove = null;\n      }\n\n      if (this.element && this.element.parentNode) {\n        this.element.parentNode.removeChild(this.element);\n      }\n\n      this.element = null;\n\n      if (this.revokeBtn && this.revokeBtn.parentNode) {\n        this.revokeBtn.parentNode.removeChild(this.revokeBtn);\n      }\n\n      this.revokeBtn = null;\n      removeCustomStyle(this.options.palette);\n      this.options = null;\n    };\n\n    CookiePopup.prototype.open = function (callback) {\n      if (!this.element) return;\n\n      if (!this.isOpen()) {\n        if (cc.hasTransition) {\n          this.fadeIn();\n        } else {\n          this.element.style.display = '';\n        }\n\n        if (this.options.revokable) {\n          this.toggleRevokeButton();\n        }\n\n        this.options.onPopupOpen.call(this);\n      }\n\n      return this;\n    };\n\n    CookiePopup.prototype.close = function (showRevoke) {\n      if (!this.element) return;\n\n      if (this.isOpen()) {\n        if (cc.hasTransition) {\n          this.fadeOut();\n        } else {\n          this.element.style.display = 'none';\n        }\n\n        if (showRevoke && this.options.revokable) {\n          this.toggleRevokeButton(true);\n        }\n\n        this.options.onPopupClose.call(this);\n      }\n\n      return this;\n    };\n\n    CookiePopup.prototype.fadeIn = function () {\n      var el = this.element;\n      if (!cc.hasTransition || !el) return; // This should always be called AFTER fadeOut (which is governed by the 'transitionend' event).\n      // 'transitionend' isn't all that reliable, so, if we try and fadeIn before 'transitionend' has\n      // has a chance to run, then we run it ourselves\n\n      if (this.afterTransition) {\n        afterFadeOut.call(this, el);\n      }\n\n      if (util.hasClass(el, 'cc-invisible')) {\n        el.style.display = '';\n\n        if (this.options.static) {\n          var height = this.element.clientHeight;\n          this.element.parentNode.style.maxHeight = height + 'px';\n        }\n\n        var fadeInTimeout = 20; // (ms) DO NOT MAKE THIS VALUE SMALLER. See below\n        // Although most browsers can handle values less than 20ms, it should remain above this value.\n        // This is because we are waiting for a \"browser redraw\" before we remove the 'cc-invisible' class.\n        // If the class is remvoed before a redraw could happen, then the fadeIn effect WILL NOT work, and\n        // the popup will appear from nothing. Therefore we MUST allow enough time for the browser to do\n        // its thing. The actually difference between using 0 and 20 in a set timeout is neglegible anyway\n\n        this.openingTimeout = setTimeout(afterFadeIn.bind(this, el), fadeInTimeout);\n      }\n    };\n\n    CookiePopup.prototype.fadeOut = function () {\n      var el = this.element;\n      if (!cc.hasTransition || !el) return;\n\n      if (this.openingTimeout) {\n        clearTimeout(this.openingTimeout);\n        afterFadeIn.bind(this, el);\n      }\n\n      if (!util.hasClass(el, 'cc-invisible')) {\n        if (this.options.static) {\n          this.element.parentNode.style.maxHeight = '';\n        }\n\n        this.afterTransition = afterFadeOut.bind(this, el);\n        el.addEventListener(cc.transitionEnd, this.afterTransition);\n        util.addClass(el, 'cc-invisible');\n      }\n    };\n\n    CookiePopup.prototype.isOpen = function () {\n      return this.element && this.element.style.display == '' && (cc.hasTransition ? !util.hasClass(this.element, 'cc-invisible') : true);\n    };\n\n    CookiePopup.prototype.toggleRevokeButton = function (show) {\n      if (this.revokeBtn) this.revokeBtn.style.display = show ? '' : 'none';\n    };\n\n    CookiePopup.prototype.revokeChoice = function (preventOpen) {\n      this.options.enabled = true;\n      this.clearStatus();\n      this.options.onRevokeChoice.call(this);\n\n      if (!preventOpen) {\n        this.autoOpen();\n      }\n    }; // returns true if the cookie has a valid value\n\n\n    CookiePopup.prototype.hasAnswered = function (options) {\n      return Object.keys(cc.status).indexOf(this.getStatus()) >= 0;\n    }; // returns true if the cookie indicates that consent has been given\n\n\n    CookiePopup.prototype.hasConsented = function (options) {\n      var val = this.getStatus();\n      return val == cc.status.allow || val == cc.status.dismiss;\n    }; // opens the popup if no answer has been given\n\n\n    CookiePopup.prototype.autoOpen = function (options) {\n      if (!this.hasAnswered() && this.options.enabled) {\n        this.open();\n      } else if (this.hasAnswered() && this.options.revokable) {\n        this.toggleRevokeButton(true);\n      }\n    };\n\n    CookiePopup.prototype.setStatus = function (status) {\n      var c = this.options.cookie;\n      var value = util.getCookie(c.name);\n      var chosenBefore = Object.keys(cc.status).indexOf(value) >= 0; // if `status` is valid\n\n      if (Object.keys(cc.status).indexOf(status) >= 0) {\n        util.setCookie(c.name, status, c.expiryDays, c.domain, c.path, c.secure);\n        this.options.onStatusChange.call(this, status, chosenBefore);\n      } else {\n        this.clearStatus();\n      }\n    };\n\n    CookiePopup.prototype.getStatus = function () {\n      return util.getCookie(this.options.cookie.name);\n    };\n\n    CookiePopup.prototype.clearStatus = function () {\n      var c = this.options.cookie;\n      util.setCookie(c.name, '', -1, c.domain, c.path);\n    }; // This needs to be called after 'fadeIn'. This is the code that actually causes the fadeIn to work\n    // There is a good reason why it's called in a timeout. Read 'fadeIn';\n\n\n    function afterFadeIn(el) {\n      this.openingTimeout = null;\n      util.removeClass(el, 'cc-invisible');\n    } // This is called on 'transitionend' (only on the transition of the fadeOut). That's because after we've faded out, we need to\n    // set the display to 'none' (so there aren't annoying invisible popups all over the page). If for whenever reason this function\n    // is not called (lack of support), the open/close mechanism will still work.\n\n\n    function afterFadeOut(el) {\n      el.style.display = 'none'; // after close and before open, the display should be none\n\n      el.removeEventListener(cc.transitionEnd, this.afterTransition);\n      this.afterTransition = null;\n    } // this function calls the `onComplete` hook and returns true (if needed) and returns false otherwise\n\n\n    function checkCallbackHooks() {\n      var complete = this.options.onInitialise.bind(this);\n\n      if (!window.navigator.cookieEnabled) {\n        complete(cc.status.deny);\n        return true;\n      }\n\n      if (window.CookiesOK || window.navigator.CookiesOK) {\n        complete(cc.status.allow);\n        return true;\n      }\n\n      var allowed = Object.keys(cc.status);\n      var answer = this.getStatus();\n      var match = allowed.indexOf(answer) >= 0;\n\n      if (match) {\n        complete(answer);\n      }\n\n      return match;\n    }\n\n    function getPositionClasses() {\n      var positions = this.options.position.split('-'); // top, bottom, left, right\n\n      var classes = []; // top, left, right, bottom\n\n      positions.forEach(function (cur) {\n        classes.push('cc-' + cur);\n      });\n      return classes;\n    }\n\n    function getPopupClasses() {\n      var opts = this.options;\n      var positionStyle = opts.position == 'top' || opts.position == 'bottom' ? 'banner' : 'floating';\n\n      if (util.isMobile()) {\n        positionStyle = 'floating';\n      }\n\n      var classes = ['cc-' + positionStyle, // floating or banner\n      'cc-type-' + opts.type, // add the compliance type\n      'cc-theme-' + opts.theme // add the theme\n      ];\n\n      if (opts.static) {\n        classes.push('cc-static');\n      }\n\n      classes.push.apply(classes, getPositionClasses.call(this)); // we only add extra styles if `palette` has been set to a valid value\n\n      var didAttach = attachCustomPalette.call(this, this.options.palette); // if we override the palette, add the class that enables this\n\n      if (this.customStyleSelector) {\n        classes.push(this.customStyleSelector);\n      }\n\n      return classes;\n    }\n\n    function getPopupInnerMarkup() {\n      var interpolated = {};\n      var opts = this.options; // removes link if showLink is false\n\n      if (!opts.showLink) {\n        opts.elements.link = '';\n        opts.elements.messagelink = opts.elements.message;\n      }\n\n      Object.keys(opts.elements).forEach(function (prop) {\n        interpolated[prop] = util.interpolateString(opts.elements[prop], function (name) {\n          var str = opts.content[name];\n          return name && typeof str == 'string' && str.length ? str : '';\n        });\n      }); // checks if the type is valid and defaults to info if it's not\n\n      var complianceType = opts.compliance[opts.type];\n\n      if (!complianceType) {\n        complianceType = opts.compliance.info;\n      } // build the compliance types from the already interpolated `elements`\n\n\n      interpolated.compliance = util.interpolateString(complianceType, function (name) {\n        return interpolated[name];\n      }); // checks if the layout is valid and defaults to basic if it's not\n\n      var layout = opts.layouts[opts.layout];\n\n      if (!layout) {\n        layout = opts.layouts.basic;\n      }\n\n      return util.interpolateString(layout, function (match) {\n        return interpolated[match];\n      });\n    }\n\n    function appendMarkup(markup) {\n      var opts = this.options;\n      var div = document.createElement('div');\n      var cont = opts.container && opts.container.nodeType === 1 ? opts.container : document.body;\n      div.innerHTML = markup;\n      var el = div.children[0];\n      el.style.display = 'none';\n\n      if (util.hasClass(el, 'cc-window') && cc.hasTransition) {\n        util.addClass(el, 'cc-invisible');\n      } // save ref to the function handle so we can unbind it later\n\n\n      this.onButtonClick = handleButtonClick.bind(this);\n      el.addEventListener('click', this.onButtonClick);\n\n      if (opts.autoAttach) {\n        if (!cont.firstChild) {\n          cont.appendChild(el);\n        } else {\n          cont.insertBefore(el, cont.firstChild);\n        }\n      }\n\n      return el;\n    }\n\n    function handleButtonClick(event) {\n      // returns the parent element with the specified class, or the original element - null if not found\n      var btn = util.traverseDOMPath(event.target, 'cc-btn') || event.target;\n\n      if (util.hasClass(btn, 'cc-btn')) {\n        var matches = btn.className.match(new RegExp('\\\\bcc-(' + __allowedStatuses.join('|') + ')\\\\b'));\n        var match = matches && matches[1] || false;\n\n        if (match) {\n          this.setStatus(match);\n          this.close(true);\n        }\n      }\n\n      if (util.hasClass(btn, 'cc-close')) {\n        this.setStatus(cc.status.dismiss);\n        this.close(true);\n      }\n\n      if (util.hasClass(btn, 'cc-revoke')) {\n        this.revokeChoice();\n      }\n    } // I might change this function to use inline styles. I originally chose a stylesheet because I could select many elements with a\n    // single rule (something that happened a lot), the apps has changed slightly now though, so inline styles might be more applicable.\n\n\n    function attachCustomPalette(palette) {\n      var hash = util.hash(JSON.stringify(palette));\n      var selector = 'cc-color-override-' + hash;\n      var isValid = util.isPlainObject(palette);\n      this.customStyleSelector = isValid ? selector : null;\n\n      if (isValid) {\n        addCustomStyle(hash, palette, '.' + selector);\n      }\n\n      return isValid;\n    }\n\n    function addCustomStyle(hash, palette, prefix) {\n      // only add this if a style like it doesn't exist\n      if (cc.customStyles[hash]) {\n        // custom style already exists, so increment the reference count\n        ++cc.customStyles[hash].references;\n        return;\n      }\n\n      var colorStyles = {};\n      var popup = palette.popup;\n      var button = palette.button;\n      var highlight = palette.highlight; // needs background colour, text and link will be set to black/white if not specified\n\n      if (popup) {\n        // assumes popup.background is set\n        popup.text = popup.text ? popup.text : util.getContrast(popup.background);\n        popup.link = popup.link ? popup.link : popup.text;\n        colorStyles[prefix + '.cc-window'] = ['color: ' + popup.text, 'background-color: ' + popup.background];\n        colorStyles[prefix + '.cc-revoke'] = ['color: ' + popup.text, 'background-color: ' + popup.background];\n        colorStyles[prefix + ' .cc-link,' + prefix + ' .cc-link:active,' + prefix + ' .cc-link:visited'] = ['color: ' + popup.link];\n\n        if (button) {\n          // assumes button.background is set\n          button.text = button.text ? button.text : util.getContrast(button.background);\n          button.border = button.border ? button.border : 'transparent';\n          colorStyles[prefix + ' .cc-btn'] = ['color: ' + button.text, 'border-color: ' + button.border, 'background-color: ' + button.background];\n\n          if (button.padding) {\n            colorStyles[prefix + ' .cc-btn'].push('padding: ' + button.padding);\n          }\n\n          if (button.background != 'transparent') {\n            colorStyles[prefix + ' .cc-btn:hover, ' + prefix + ' .cc-btn:focus'] = ['background-color: ' + (button.hover || getHoverColour(button.background))];\n          }\n\n          if (highlight) {\n            //assumes highlight.background is set\n            highlight.text = highlight.text ? highlight.text : util.getContrast(highlight.background);\n            highlight.border = highlight.border ? highlight.border : 'transparent';\n            colorStyles[prefix + ' .cc-highlight .cc-btn:first-child'] = ['color: ' + highlight.text, 'border-color: ' + highlight.border, 'background-color: ' + highlight.background];\n          } else {\n            // sets highlight text color to popup text. background and border are transparent by default.\n            colorStyles[prefix + ' .cc-highlight .cc-btn:first-child'] = ['color: ' + popup.text];\n          }\n        }\n      } // this will be interpretted as CSS. the key is the selector, and each array element is a rule\n\n\n      var style = document.createElement('style');\n      document.head.appendChild(style); // custom style doesn't exist, so we create it\n\n      cc.customStyles[hash] = {\n        references: 1,\n        element: style.sheet\n      };\n      var ruleIndex = -1;\n\n      for (var prop in colorStyles) {\n        if (colorStyles.hasOwnProperty(prop)) {\n          style.sheet.insertRule(prop + '{' + colorStyles[prop].join(';') + '}', ++ruleIndex);\n        }\n      }\n    }\n\n    function getHoverColour(hex) {\n      hex = util.normaliseHex(hex); // for black buttons\n\n      if (hex == '000000') {\n        return '#222';\n      }\n\n      return util.getLuminance(hex);\n    }\n\n    function removeCustomStyle(palette) {\n      if (util.isPlainObject(palette)) {\n        var hash = util.hash(JSON.stringify(palette));\n        var customStyle = cc.customStyles[hash];\n\n        if (customStyle && ! --customStyle.references) {\n          var styleNode = customStyle.element.ownerNode;\n\n          if (styleNode && styleNode.parentNode) {\n            styleNode.parentNode.removeChild(styleNode);\n          }\n\n          cc.customStyles[hash] = null;\n        }\n      }\n    }\n\n    function arrayContainsMatches(array, search) {\n      for (var i = 0, l = array.length; i < l; ++i) {\n        var str = array[i]; // if regex matches or string is equal, return true\n\n        if (str instanceof RegExp && str.test(search) || typeof str == 'string' && str.length && str === search) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function applyAutoDismiss() {\n      var setStatus = this.setStatus.bind(this);\n      var close = this.close.bind(this);\n      var delay = this.options.dismissOnTimeout;\n\n      if (typeof delay == 'number' && delay >= 0) {\n        this.dismissTimeout = window.setTimeout(function () {\n          setStatus(cc.status.dismiss);\n          close(true);\n        }, Math.floor(delay));\n      }\n\n      var scrollRange = this.options.dismissOnScroll;\n\n      if (typeof scrollRange == 'number' && scrollRange >= 0) {\n        var onWindowScroll = function onWindowScroll(evt) {\n          if (window.pageYOffset > Math.floor(scrollRange)) {\n            setStatus(cc.status.dismiss);\n            close(true);\n            window.removeEventListener('scroll', onWindowScroll);\n            this.onWindowScroll = null;\n          }\n        };\n\n        if (this.options.enabled) {\n          this.onWindowScroll = onWindowScroll;\n          window.addEventListener('scroll', onWindowScroll);\n        }\n      }\n\n      var windowClick = this.options.dismissOnWindowClick;\n      var ignoredClicks = this.options.ignoreClicksFrom;\n\n      if (windowClick) {\n        var onWindowClick = function (evt) {\n          var isIgnored = false;\n          var pathLen = evt.path.length;\n          var ignoredLen = ignoredClicks.length;\n\n          for (var i = 0; i < pathLen; i++) {\n            if (isIgnored) continue;\n\n            for (var i2 = 0; i2 < ignoredLen; i2++) {\n              if (isIgnored) continue;\n              isIgnored = util.hasClass(evt.path[i], ignoredClicks[i2]);\n            }\n          }\n\n          if (!isIgnored) {\n            setStatus(cc.status.dismiss);\n            close(true);\n            window.removeEventListener('click', onWindowClick);\n            this.onWindowClick = null;\n          }\n        }.bind(this);\n\n        if (this.options.enabled) {\n          this.onWindowClick = onWindowClick;\n          window.addEventListener('click', onWindowClick);\n        }\n      }\n    }\n\n    function applyRevokeButton() {\n      // revokable is true if advanced compliance is selected\n      if (this.options.type != 'info') this.options.revokable = true; // animateRevokable false for mobile devices\n\n      if (util.isMobile()) this.options.animateRevokable = false;\n\n      if (this.options.revokable) {\n        var classes = getPositionClasses.call(this);\n\n        if (this.options.animateRevokable) {\n          classes.push('cc-animate');\n        }\n\n        if (this.customStyleSelector) {\n          classes.push(this.customStyleSelector);\n        }\n\n        var revokeBtn = this.options.revokeBtn.replace('{{classes}}', classes.join(' ')).replace('{{policy}}', this.options.content.policy);\n        this.revokeBtn = appendMarkup.call(this, revokeBtn);\n        var btn = this.revokeBtn;\n\n        if (this.options.animateRevokable) {\n          var wait = false;\n          var onMouseMove = util.throttle(function (evt) {\n            var active = false;\n            var minY = 20;\n            var maxY = window.innerHeight - 20;\n            if (util.hasClass(btn, 'cc-top') && evt.clientY < minY) active = true;\n            if (util.hasClass(btn, 'cc-bottom') && evt.clientY > maxY) active = true;\n\n            if (active) {\n              if (!util.hasClass(btn, 'cc-active')) {\n                util.addClass(btn, 'cc-active');\n              }\n            } else {\n              if (util.hasClass(btn, 'cc-active')) {\n                util.removeClass(btn, 'cc-active');\n              }\n            }\n          }, 200);\n          this.onMouseMove = onMouseMove;\n          window.addEventListener('mousemove', onMouseMove);\n        }\n      }\n    }\n\n    return CookiePopup;\n  }();\n\n  cc.Location = function () {\n    // An object containing all the location services we have already set up.\n    // When using a service, it could either return a data structure in plain text (like a JSON object) or an executable script\n    // When the response needs to be executed by the browser, then `isScript` must be set to true, otherwise it won't work.\n    // When the service uses a script, the chances are that you'll have to use the script to make additional requests. In these\n    // cases, the services `callback` property is called with a `done` function. When performing async operations, this must be called\n    // with the data (or Error), and `cookieconsent.locate` will take care of the rest\n    var defaultOptions = {\n      // The default timeout is 5 seconds. This is mainly needed to catch JSONP requests that error.\n      // Otherwise there is no easy way to catch JSONP errors. That means that if a JSONP fails, the\n      // app will take `timeout` milliseconds to react to a JSONP network error.\n      timeout: 5000,\n      // the order that services will be attempted in\n      services: ['ipinfo'\n      /*\n         // 'ipinfodb' requires some options, so we define it using an object\n      // this object will be passed to the function that defines the service\n         {\n        name: 'ipinfodb',\n        interpolateUrl: {\n          // obviously, this is a fake key\n          api_key: 'vOgI3748dnIytIrsJcxS7qsDf6kbJkE9lN4yEDrXAqXcKUNvjjZPox3ekXqmMMld'\n        },\n      },\n         // as well as defining an object, you can define a function that returns an object\n         function () {\n        return {name: 'ipinfodb'};\n      },\n         */\n      ],\n      serviceDefinitions: {\n        ipinfo: function ipinfo() {\n          return {\n            // This service responds with JSON, so we simply need to parse it and return the country code\n            url: '//ipinfo.io',\n            headers: ['Accept: application/json'],\n            callback: function callback(done, response) {\n              try {\n                var json = JSON.parse(response);\n                return json.error ? toError(json) : {\n                  code: json.country\n                };\n              } catch (err) {\n                return toError({\n                  error: 'Invalid response (' + err + ')'\n                });\n              }\n            }\n          };\n        },\n        // This service requires an option to define `key`. Options are proived using objects or functions\n        ipinfodb: function ipinfodb(options) {\n          return {\n            // This service responds with JSON, so we simply need to parse it and return the country code\n            url: '//api.ipinfodb.com/v3/ip-country/?key={api_key}&format=json&callback={callback}',\n            isScript: true,\n            // this is JSONP, therefore we must set it to run as a script\n            callback: function callback(done, response) {\n              try {\n                var json = JSON.parse(response);\n                return json.statusCode == 'ERROR' ? toError({\n                  error: json.statusMessage\n                }) : {\n                  code: json.countryCode\n                };\n              } catch (err) {\n                return toError({\n                  error: 'Invalid response (' + err + ')'\n                });\n              }\n            }\n          };\n        },\n        maxmind: function maxmind() {\n          return {\n            // This service responds with a JavaScript file which defines additional functionality. Once loaded, we must\n            // make an additional AJAX call. Therefore we provide a `done` callback that can be called asynchronously\n            url: '//js.maxmind.com/js/apis/geoip2/v2.1/geoip2.js',\n            isScript: true,\n            // this service responds with a JavaScript file, so it must be run as a script\n            callback: function callback(done) {\n              // if everything went okay then `geoip2` WILL be defined\n              if (!window.geoip2) {\n                done(new Error('Unexpected response format. The downloaded script should have exported `geoip2` to the global scope'));\n                return;\n              }\n\n              geoip2.country(function (location) {\n                try {\n                  done({\n                    code: location.country.iso_code\n                  });\n                } catch (err) {\n                  done(toError(err));\n                }\n              }, function (err) {\n                done(toError(err));\n              }); // We can't return anything, because we need to wait for the second AJAX call to return.\n              // Then we can 'complete' the service by passing data or an error to the `done` callback.\n            }\n          };\n        }\n      }\n    };\n\n    function Location(options) {\n      // Set up options\n      util.deepExtend(this.options = {}, defaultOptions);\n\n      if (util.isPlainObject(options)) {\n        util.deepExtend(this.options, options);\n      }\n\n      this.currentServiceIndex = -1; // the index (in options) of the service we're currently using\n    }\n\n    Location.prototype.getNextService = function () {\n      var service;\n\n      do {\n        service = this.getServiceByIdx(++this.currentServiceIndex);\n      } while (this.currentServiceIndex < this.options.services.length && !service);\n\n      return service;\n    };\n\n    Location.prototype.getServiceByIdx = function (idx) {\n      // This can either be the name of a default locationService, or a function.\n      var serviceOption = this.options.services[idx]; // If it's a string, use one of the location services.\n\n      if (typeof serviceOption === 'function') {\n        var dynamicOpts = serviceOption();\n\n        if (dynamicOpts.name) {\n          util.deepExtend(dynamicOpts, this.options.serviceDefinitions[dynamicOpts.name](dynamicOpts));\n        }\n\n        return dynamicOpts;\n      } // If it's a string, use one of the location services.\n\n\n      if (typeof serviceOption === 'string') {\n        return this.options.serviceDefinitions[serviceOption]();\n      } // If it's an object, assume {name: 'ipinfo', ...otherOptions}\n      // Allows user to pass in API keys etc.\n\n\n      if (util.isPlainObject(serviceOption)) {\n        return this.options.serviceDefinitions[serviceOption.name](serviceOption);\n      }\n\n      return null;\n    }; // This runs the service located at index `currentServiceIndex`.\n    // If the service fails, `runNextServiceOnError` will continue trying each service until all fail, or one completes successfully\n\n\n    Location.prototype.locate = function (complete, error) {\n      var service = this.getNextService();\n\n      if (!service) {\n        error(new Error('No services to run'));\n        return;\n      }\n\n      this.callbackComplete = complete;\n      this.callbackError = error;\n      this.runService(service, this.runNextServiceOnError.bind(this));\n    }; // Potentially adds a callback to a url for jsonp.\n\n\n    Location.prototype.setupUrl = function (service) {\n      var serviceOpts = this.getCurrentServiceOpts();\n      return service.url.replace(/\\{(.*?)\\}/g, function (_, param) {\n        if (param === 'callback') {\n          var tempName = 'callback' + Date.now();\n\n          window[tempName] = function (res) {\n            service.__JSONP_DATA = JSON.stringify(res);\n          };\n\n          return tempName;\n        }\n\n        if (param in serviceOpts.interpolateUrl) {\n          return serviceOpts.interpolateUrl[param];\n        }\n      });\n    }; // requires a `service` object that defines at least a `url` and `callback`\n\n\n    Location.prototype.runService = function (service, complete) {\n      var self = this; // basic check to ensure it resembles a `service`\n\n      if (!service || !service.url || !service.callback) {\n        return;\n      } // we call either `getScript` or `makeAsyncRequest` depending on the type of resource\n\n\n      var requestFunction = service.isScript ? getScript : makeAsyncRequest;\n      var url = this.setupUrl(service); // both functions have similar signatures so we can pass the same arguments to both\n\n      requestFunction(url, function (xhr) {\n        // if `!xhr`, then `getScript` function was used, so there is no response text\n        var responseText = xhr ? xhr.responseText : ''; // if the resource is a script, then this function is called after the script has been run.\n        // if the script is JSONP, then a time defined function `callback_{Date.now}` has already\n        // been called (as the JSONP callback). This callback sets the __JSONP_DATA property\n\n        if (service.__JSONP_DATA) {\n          responseText = service.__JSONP_DATA;\n          delete service.__JSONP_DATA;\n        } // call the service callback with the response text (so it can parse the response)\n\n\n        self.runServiceCallback.call(self, complete, service, responseText);\n      }, this.options.timeout, service.data, service.headers); // `service.data` and `service.headers` are optional (they only count if `!service.isScript` anyway)\n    }; // The service request has run (and possibly has a `responseText`) [no `responseText` if `isScript`]\n    // We need to run its callback which determines if its successful or not\n    // `complete` is called on success or failure\n\n\n    Location.prototype.runServiceCallback = function (complete, service, responseText) {\n      var self = this; // this is the function that is called if the service uses the async callback in its handler method\n\n      var serviceResultHandler = function serviceResultHandler(asyncResult) {\n        // if `result` is a valid value, then this function shouldn't really run\n        // even if it is called by `service.callback`\n        if (!result) {\n          self.onServiceResult.call(self, complete, asyncResult);\n        }\n      }; // the function `service.callback` will either extract a country code from `responseText` and return it (in `result`)\n      // or (if it has to make additional requests) it will call a `done` callback with the country code when it is ready\n\n\n      var result = service.callback(serviceResultHandler, responseText);\n\n      if (result) {\n        this.onServiceResult.call(this, complete, result);\n      }\n    }; // This is called with the `result` from `service.callback` regardless of how it provided that result (sync or async).\n    // `result` will be whatever is returned from `service.callback`. A service callback should provide an object with data\n\n\n    Location.prototype.onServiceResult = function (complete, result) {\n      // convert result to nodejs style async callback\n      if (result instanceof Error || result && result.error) {\n        complete.call(this, result, null);\n      } else {\n        complete.call(this, null, result);\n      }\n    }; // if `err` is set, the next service handler is called\n    // if `err` is null, the `onComplete` handler is called with `data`\n\n\n    Location.prototype.runNextServiceOnError = function (err, data) {\n      if (err) {\n        this.logError(err);\n        var nextService = this.getNextService();\n\n        if (nextService) {\n          this.runService(nextService, this.runNextServiceOnError.bind(this));\n        } else {\n          this.completeService.call(this, this.callbackError, new Error('All services failed'));\n        }\n      } else {\n        this.completeService.call(this, this.callbackComplete, data);\n      }\n    };\n\n    Location.prototype.getCurrentServiceOpts = function () {\n      var val = this.options.services[this.currentServiceIndex];\n\n      if (typeof val == 'string') {\n        return {\n          name: val\n        };\n      }\n\n      if (typeof val == 'function') {\n        return val();\n      }\n\n      if (util.isPlainObject(val)) {\n        return val;\n      }\n\n      return {};\n    }; // calls the `onComplete` callback after resetting the `currentServiceIndex`\n\n\n    Location.prototype.completeService = function (fn, data) {\n      this.currentServiceIndex = -1;\n      fn && fn(data);\n    };\n\n    Location.prototype.logError = function (err) {\n      var idx = this.currentServiceIndex;\n      var service = this.getServiceByIdx(idx);\n      console.warn('The service[' + idx + '] (' + service.url + ') responded with the following error', err);\n    };\n\n    function getScript(url, callback, timeout) {\n      var timeoutIdx,\n          s = document.createElement('script');\n      s.type = 'text/' + (url.type || 'javascript');\n      s.src = url.src || url;\n      s.async = false;\n\n      s.onreadystatechange = s.onload = function () {\n        // this code handles two scenarios, whether called by onload or onreadystatechange\n        var state = s.readyState;\n        clearTimeout(timeoutIdx);\n\n        if (!callback.done && (!state || /loaded|complete/.test(state))) {\n          callback.done = true;\n          callback();\n          s.onreadystatechange = s.onload = null;\n        }\n      };\n\n      document.body.appendChild(s); // You can't catch JSONP Errors, because it's handled by the script tag\n      // one way is to use a timeout\n\n      timeoutIdx = setTimeout(function () {\n        callback.done = true;\n        callback();\n        s.onreadystatechange = s.onload = null;\n      }, timeout);\n    }\n\n    function makeAsyncRequest(url, onComplete, timeout, postData, requestHeaders) {\n      var xhr = new (window.XMLHttpRequest || window.ActiveXObject)('MSXML2.XMLHTTP.3.0');\n      xhr.open(postData ? 'POST' : 'GET', url, 1);\n      xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n\n      if (Array.isArray(requestHeaders)) {\n        for (var i = 0, l = requestHeaders.length; i < l; ++i) {\n          var split = requestHeaders[i].split(':', 2);\n          xhr.setRequestHeader(split[0].replace(/^\\s+|\\s+$/g, ''), split[1].replace(/^\\s+|\\s+$/g, ''));\n        }\n      }\n\n      if (typeof onComplete == 'function') {\n        xhr.onreadystatechange = function () {\n          if (xhr.readyState > 3) {\n            onComplete(xhr);\n          }\n        };\n      }\n\n      xhr.send(postData);\n    }\n\n    function toError(obj) {\n      return new Error('Error [' + (obj.code || 'UNKNOWN') + ']: ' + obj.error);\n    }\n\n    return Location;\n  }();\n\n  cc.Law = function () {\n    var defaultOptions = {\n      // Make this false if you want to disable all regional overrides for settings.\n      // If true, options can differ by country, depending on their cookie law.\n      // It does not affect hiding the popup for countries that do not have cookie law.\n      regionalLaw: true,\n      // countries that enforce some version of a cookie law\n      hasLaw: ['AT', 'BE', 'BG', 'HR', 'CZ', 'CY', 'DK', 'EE', 'FI', 'FR', 'DE', 'EL', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'SK', 'ES', 'SE', 'GB', 'UK', 'GR', 'EU'],\n      // countries that say that all cookie consent choices must be revokable (a user must be able too change their mind)\n      revokable: ['HR', 'CY', 'DK', 'EE', 'FR', 'DE', 'LV', 'LT', 'NL', 'PT', 'ES'],\n      // countries that say that a person can only \"consent\" if the explicitly click on \"I agree\".\n      // in these countries, consent cannot be implied via a timeout or by scrolling down the page\n      explicitAction: ['HR', 'IT', 'ES']\n    };\n\n    function Law(options) {\n      this.initialise.apply(this, arguments);\n    }\n\n    Law.prototype.initialise = function (options) {\n      // set options back to default options\n      util.deepExtend(this.options = {}, defaultOptions); // merge in user options\n\n      if (util.isPlainObject(options)) {\n        util.deepExtend(this.options, options);\n      }\n    };\n\n    Law.prototype.get = function (countryCode) {\n      var opts = this.options;\n      return {\n        hasLaw: opts.hasLaw.indexOf(countryCode) >= 0,\n        revokable: opts.revokable.indexOf(countryCode) >= 0,\n        explicitAction: opts.explicitAction.indexOf(countryCode) >= 0\n      };\n    };\n\n    Law.prototype.applyLaw = function (options, countryCode) {\n      var country = this.get(countryCode);\n\n      if (!country.hasLaw) {\n        // The country has no cookie law\n        options.enabled = false;\n\n        if (typeof options.onNoCookieLaw === 'function') {\n          options.onNoCookieLaw(countryCode, country);\n        }\n      }\n\n      if (this.options.regionalLaw) {\n        if (country.revokable) {\n          // We must provide an option to revoke consent at a later time\n          options.revokable = true;\n        }\n\n        if (country.explicitAction) {\n          // The user must explicitly click the consent button\n          options.dismissOnScroll = false;\n          options.dismissOnTimeout = false;\n        }\n      }\n\n      return options;\n    };\n\n    return Law;\n  }(); // This function initialises the app by combining the use of the Popup, Locator and Law modules\n  // You can string together these three modules yourself however you want, by writing a new function.\n\n\n  cc.initialise = function (options, complete, error) {\n    var law = new cc.Law(options.law);\n    if (!complete) complete = function complete() {};\n    if (!error) error = function error() {}; // I hardcoded this because I cba to refactor a fuck load of code.\n    // Bad developer. Bad.\n\n    var allowed = Object.keys(cc.status);\n    var answer = util.getCookie('cookieconsent_status');\n    var match = allowed.indexOf(answer) >= 0; // if they have already answered\n\n    if (match) {\n      complete(new cc.Popup(options));\n      return;\n    }\n\n    cc.getCountryCode(options, function (result) {\n      // don't need the law or location options anymore\n      delete options.law;\n      delete options.location;\n\n      if (result.code) {\n        options = law.applyLaw(options, result.code);\n      }\n\n      complete(new cc.Popup(options));\n    }, function (err) {\n      // don't need the law or location options anymore\n      delete options.law;\n      delete options.location;\n      error(err, new cc.Popup(options));\n    });\n  }; // This function tries to find your current location. It either grabs it from a hardcoded option in\n  // `options.law.countryCode`, or attempts to make a location service request. This function accepts\n  // options (which can configure the `law` and `location` modules) and fires a callback with which\n  // passes an object `{code: countryCode}` as the first argument (which can have undefined properties)\n\n\n  cc.getCountryCode = function (options, complete, error) {\n    if (options.law && options.law.countryCode) {\n      complete({\n        code: options.law.countryCode\n      });\n      return;\n    }\n\n    if (options.location) {\n      var locator = new cc.Location(options.location);\n      locator.locate(function (serviceResult) {\n        complete(serviceResult || {});\n      }, error);\n      return;\n    }\n\n    complete({});\n  }; // export utils (no point in hiding them, so we may as well expose them)\n\n\n  cc.utils = util; // prevent this code from being run twice\n\n  cc.hasInitialised = true;\n  window.cookieconsent = cc;\n})(window.cookieconsent || {});"}});